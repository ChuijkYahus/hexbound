{
    hexcasting: {
        mishap: {
            no_construct: "%s can only be executed by a Construct",
            construct_forbidden: "%s takes orders only from %s",
            bad_block: {
                stored_impetus: "a Cleric Impetus bound to someone present",
                construct_broadcaster: "a Construct Broadcaster"
            },
            invalid_value: {
                entity: {
                    construct: {
                        generic: "a Construct",
                        spider: "a Spider Construct",
                        blaze: "an Unstable Blaze Construct"
                    },
                    allay: "an Allay"
                },
                item_stack: "an Item Stack",
                bindable: "a player, pattern, or Null",
                spider_component: {
                    "": "a Spider Construct Core or a fully charged Spider Construct Battery",
                    "core": "a Spider Construct Core",
                    "battery": "a fully charged Spider Construct Battery"
                }
            },
            colorizer: {
                missing_key: 'Pattern "%s" does not match a saved pigment',
                absent: "No pigment is present to be saved",
                storage_full: "Too many pigments have already been stored"
            },
            disallowed_construct: "%s is not allowed for Constructs",
            target_not_enlightened: "%s is not enlightened enough"
        },
        "iota.hexbound:": {
            item: "Item",
            item_stack: "Item Stack"
        },
        "spell.hexbound:": {
            "colorizer/": {
                "save": "Memorize Pigment",
                "load": "Recall Pigment",
                "delete": "Forget Pigment"
            },
            set_fake_impetus_player: "Bind Figment",
            rotate_pattern: "Revolving Distillation",
            merge_patterns: "Painter's Distillation",
            construct_get_self: "Automaton's Reflection",
            "give_command/": {
                pick_up: "Command: Pick Up Item",
                drop_off: "Command: Drop Item",
                move_to: "Command: Move To Position",
                "harvest": "Command: Harvest",
                "use/": {
                    block: "Command: Use On Block"
                }
            },
            bind_construct: "Artificer's Gambit",
            "instructions/": {
                send: "Send Instructions",
                broadcast: "Broadcast Instructions"
            },
            get_main_hand: "Duelist's Purification",
            get_off_hand: "Shieldbearer's Purification",
            "get_inventory/": {
                stacks: "Hoarder's Distillation",
                items: "Collector's Distillation"
            },
            get_entity_item: "Sweeper's Purification",
            "get_stack_prop/": {
                "size": "Treasurer's Purification",
                "item": "Logistician's Purification"
            },
            "create_construct/": {
                spider: "Create Spider Construct"
            }
        }
    },
    hexbound: {
        vector_format: "(%s, %s, %s)",
        stack: {
            format: "%dx %s",
            empty: "Empty Stack"
        },
        side: {
            north: "north",
            south: "south",
            west: "west",
            east: "east",
            up: "top",
            down: "bottom"
        },
        construct: {
            status: {
                executing: "Executing command: %s",
                error: "Execution failed: %s",
                idle: "Waiting for instructions",
                bound_player: "Bound to %s",
                bound_pattern: "Inscribed with pattern %s"
            },
            command: {
                no_op: "not doing anything",
                move_to: "moving to %s",
                drop_off: "dropping an item",
                pick_up: "picking up %s",
                harvest: "harvesting crops at %s",
                use_on_block: "using an item on %2$s of the block at %1$s",
                unknown_item: "an unknown item"
            },
            exception: {
                component_missing: {
                    "item": "%s cannot carry items"
                },
                bad_target: {
                    too_far: "%s is too far",
                    no_path_found: "could not find a path to %s",
                    could_not_reach: "could not reach %s",
                    target_expired: "%s is no longer available",
                    does_not_exist: {
                        item: "target item does not exist"
                    },
                    not_an_item: "%s is not an item",
                    forbidden: "Construct is not allowed to edit %s",
                    not_harvestable: "Block at %s is not harvestable"
                },
                no_item: "construct isn't holding an item",
                already_has_item: "construct is already carrying %s",
                unknown_error: "Unknown exception has occurred (this is likely a bug!): %s"
            }
        },
        "impetus.fake_enabled": "Contains a Figment"
    },
    entity: {
        hexbound: {
            spider_construct: "Spider Construct",
            robot_construct: "Robot Construct"
        }
    },
    "item.hexbound": {
        spider_construct_core: "Spider Construct Core",
        spider_construct_battery: {
            "": "Spider Construct Battery",
            "charge": "%d%% charged (%s/%s)",
            "full_charge": "Fully charged"
        },
    },
    "block.hexbound": {
        construct_broadcaster: "Construct Broadcaster"
    },
    "itemGroup.hexbound.hexbound_group": "Hexbound",
    "hexbound.book": {
        "category.constructs": {
            title: "Constructs",
            desc: "The patterns in this chapter allow me to manipulate Constructs: living machines capable of carrying out my orders and even casting some limited _Hexes on their own."
        },
        "basics.hexbound_exists": {
            title: "Hexbinding",
            "1": "I have found evidence of a different branch of _Hexcasting. Known as Hexbinding, this particular school uses media to create and control automata known as Constructs, manipulate items, and more. \
|                 As always, I will document my findings in this journal."
        },
        "interop.hexal": {
            title: "Hexal-Hexbound",
            "1": "It appears some of the _Hexcasting disciplines I've encountered can operate together.$(br2) \
|                 First, I've discovered that Item Iotas, as created by the likes of Duelist's Purification, and Item Type Iotas, as created by Physician's Purification, are near-identical! \
|                 Comparisons between them or their types should therefore work as expected.",
            "2": "The second and, perhaps, even more important discovery is the ability of Constructs to maintain Links. This will allow me to send iotas between Wisps and Constructs, or even Constructs and myself! The possibilities are well and truly endless."
        },
        constructs: {
            constructs_intro: {
                title: "Intro to Constructs",
                "1": "Constructs are a type of machine used by Hexbinders in ages past, and, following meticulous study of surviving blueprints, are now at my disposal.",
                "2": "What puts Constructs apart from simpler machines such as the Golems employed by villages of this world is their ability to process _Hexes and use special patterns \
|                     to interpret _Hexes as physical actions to perform. While the limitations are many, these ''commands'' allow me to encode a variety of tasks too mundane or dangerous for me to perform \
|                     as Construct instructions (unless I find myself getting attached to these inanimate objects).", //TODO rephrase this part
                "3": "First, the limitations:$(br)\
|                     $(li)Constructs are too sensitive to use their own _media for casting _Hexes. It should be assumed they do not possess any _media to spend.\
|                     $(li)Most patterns, especially Spells, directly affecting the outside world simply cannot be processed by their limited pseudo-minds.\
|                     $(li)Said pseudo-minds behave as any other Figment: Mind's Reflection will push Null, Pigments and Sentinels will not function.",
                "4": "Now, for some details about the casting mechanism:$(br)\
|                     $(li)Construct instructions are a list of Iotas and are executed immediately after each other, not unlike those contained within Casting Items.\
|                     $(li)Constructs start new instructions with an empty stack and Ravenmind.\
|                     $(li)Encountering a Mishap or an error in executing the command, cancels both the execution and any issued command, as well as clear the stack and Ravenmind.",
                send: "Some basic patterns to close off the introduction. Remove a reference to a Construct and a list of patterns from the stack and send the list as instructions to the Construct.",
                construct_self: "If executed by a Construct, puts a reference to it on the stack. Otherwise, causes a Mishap. Should be used instead of Mind's Reflection for _Hexes executed by Constructs."
            },
            executing_commands: {
                title: "Executing Commands",
                "1": "The core component of any _Hex executed by a Construct will be its commands, however there is an issue that needs to be addressed first. \
|                     Construct instructions, like any _Hex packaged into a list, execute instantly after each other. While normally not an issue, this causes multiple commands issued in a row \
|                     to replace each other, not giving even the shortest ones a moment to be executed.",
                "2": "The solution lies in the last argument to any command pattern. Once the command has finished, the construct will execute the list passed to it next. \
|                     Stack and Ravenmind remain intact between these executions, and they can be chained to execute whole sequences of commands. However, each command will \
|                     bring the spell closer to its execution limit, like Hermes' Gambit would.",
                "3": "Finally, a few notes on evaluating commands:$(br)\
|                     $(li)Commands can only be evaluated by a Construct. Doing so myself will cause a Mishap to occur.\
|                     $(li)Some commands require the Construct be able to perform certain actions like picking up items or harvesting crops. \
|                     $(li2)Should I, eventually, discover a Construct incapable of such actions, evaluating such a command will cause a Mishap.\
                      $(li)Some commands require the target be directly next to the Construct. I can expect about two blocks of leeway within which the Construct can figure the details out.",
                "4": "Should a Mishap or a command error occur, I can examine the Construct by using a Scrying Lens on it while sneaking to find the issue.$(br2)Now, for the commands themselves.",
                move_to: "Removes a vector from the stack and instructs the Construct to go to the position represented by that vector. The position must be within 32 blocks of the Construct.",
                pick_up: "Removes an entity representing a dropped item from the stack and instructs the Construct to pick it up. \
|                         The item must be next to the Construct, the construct must be able to pick items up and not be carrying one already.",
                drop_off: "Instructs the Construct to drop the item it is currently carrying. The construct must be able carrying an item.",
                harvest: "Removes a vector from the stack and instructs the Construct to harvest crops or berries at the position represented by that vector. \
|                         If harvesting the block destroys it, it will be replanted by the Construct. \
|                         The position must be next to the Construct, and the Construct must be capable of interacting with the world.",
                "use/block": "Removes two vectors from the stack and instructs the Construct to use the currently held item, if any, on the block represented by the first vector.",
                "use/block.more": "If the second vector is not zero, the block is used from the side indicated by it. If it is zero, it will be used from the side closest to the Construct. \
|                                  The position must be next to the Construct, the Construct must be capable of carrying items, and interacting with the world."
            },
            spider_construct: {
                title: "Spider Constructs",
                "1": "After careful study, experimentation, and filling in both figurative and literal holes in what blueprints I could find, I believe I'm ready to create a Construct of my own.$(br2)\
|                     Spider Constructs, as I've taken to calling them, are small, but nimble assistants capable of interacting with their surroundings, and carrying items.",
                "2": "One of the blueprints contained an alternate design for this Construct, which I replicated as best I could. The two designs can be switched by using an Iron Block or Amethyst Block \
|                     on the Construct while sneaking or, should I find the Spider form not to my taste, by enabling a form of perception filter in configuration files \
|                     to make all Constructs appear to me as their alternate design.",
                core: {
                    title: "Spider Construct Core",
                    desc: "The first of the three components required to create this Construct is the Core, a composite of the lenses, motivators, and inert _media required for the Construct's base form."
                },
                battery: {
                    title: "Spider Construct Battery",
                    desc: "The battery is the second component. While already made of a fair amount of _media, it will have to be amplified further. \
|                          Standard usage of Recharge will do, and I will be able to see the amount of $(media)Amethyst Dust$() required on the battery itself."
                },
                "3": "Some notes on the final component. The evidence I found clearly shows it is meant to be created artificially, but is not detailed enough to do so.$(br)\
|                     Fortunately, I managed to work a replacement into the process: a living Allay. A creature well-attuned to _media and already capable of carrying items makes this process almost too easy.$(br2)\
|                     Sometimes I wonder if the Allay's fate should concern me more than a passing thought.",
                create: "The inputs represent, starting from deepest on the stack, the Allay, a dropped Core, and a dropped fully-charged Battery. \
|                        The items are consumed, and the Allay is converted into a Construct."
            }
        }
    }
}
